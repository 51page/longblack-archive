<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LongBlack - Deconstructed Time-Art</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Nanum+Myeongjo:wght@800&family=Montserrat:wght@900&display=swap" rel="stylesheet">
    <style>
        :root { --bg: #000; --accent: #FF4E00; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: var(--bg); color: #fff; font-family: 'Montserrat', sans-serif; overflow: hidden; }

        /* [배경 데이터 레이어] */
        #universe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none; }
        
        .data-fragment { position: absolute; will-change: transform, opacity; }
        .data-fragment img { width: 100%; height: 100%; object-fit: cover; border-radius: 4px; opacity: 0.7; filter: grayscale(0.7); }
        
        /* [텍스트 파편 스타일] */
        .text-fragment { 
            position: absolute; color: rgba(255,255,255,0.7); font-family: 'Nanum Myeongjo'; 
            font-size: 0.7rem; white-space: nowrap; will-change: transform, opacity;
            font-weight: 800; /* 제목 강조 */
        }

        /* [중앙 시계] */
        #clock-container {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 300px; height: 300px; z-index: 100;
            display: flex; align-items: center; justify-content: center;
        }
        .clock {
            width: 100%; height: 100%; border: 2px solid rgba(255,255,255,0.1);
            border-radius: 50%; position: relative; backdrop-filter: blur(5px);
        }
        .hand { position: absolute; bottom: 50%; left: 50%; transform-origin: bottom; background: #fff; border-radius: 10px; }
        .hour { width: 6px; height: 70px; z-index: 3; }
        .min { width: 4px; height: 100px; z-index: 4; }
        .sec { width: 2px; height: 120px; background: var(--accent); z-index: 5; }
        .center-dot { position: absolute; top: 50%; left: 50%; width: 12px; height: 12px; background: var(--accent); border-radius: 50%; transform: translate(-50%, -50%); z-index: 10; }

        /* [UI] */
        #brand-logo { position: fixed; top: 40px; left: 40px; font-size: 1.5rem; letter-spacing: 5px; z-index: 1000; color: var(--accent); }
        #instruction { 
            position: fixed; bottom: 40px; left: 40px; 
            font-size: 0.7rem; opacity: 0.6; letter-spacing: 2px; z-index: 1000; 
            font-family: 'Montserrat', sans-serif;
        }
        #tagline { 
            position: fixed; top: 70px; left: 40px; 
            font-size: 0.9rem; opacity: 0.7; letter-spacing: 1px; z-index: 1000;
            font-family: 'Montserrat', sans-serif;
        }
    </style>
</head>
<body>

    <div id="brand-logo">LONGBLACK</div>
    <div id="tagline">TIME DECONSTRUCTS KNOWLEDGE INTO ART.</div>
    <div id="instruction">INSTRUCTION OPAIY x 0.0.4</div>

    <div id="universe"></div>

    <div id="clock-container">
        <div class="clock">
            <div class="center-dot"></div>
            <div id="hour-hand" class="hand hour"></div>
            <div id="min-hand" class="hand min"></div>
            <div id="sec-hand" class="hand sec"></div>
        </div>
    </div>

    <script>
        let noteData = [];
        const universe = document.getElementById('universe');

        // 초성, 중성, 종성 분리 함수 (한글)
        const HANGUL_OFFSET = 0xAC00;
        const CHOSUNG = ['ㄱ', 'ㄲ', 'ㄴ', 'ㄷ', 'ㄸ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅃ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅉ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'];
        const JUNGSUNG = ['ㅏ', 'ㅐ', 'ㅑ', 'ㅒ', 'ㅓ', 'ㅔ', 'ㅕ', 'ㅖ', 'ㅗ', ['ㅗ', 'ㅏ'], ['ㅗ', 'ㅐ'], ['ㅗ', 'ㅣ'], 'ㅛ', 'ㅜ', ['ㅜ', 'ㅓ'], ['ㅜ', 'ㅔ'], ['ㅜ', 'ㅣ'], 'ㅠ', 'ㅡ', ['ㅡ', 'ㅣ'], ['ㅡ', ' E'], 'ㅣ'];
        const JONGSUNG = ['', 'ㄱ', 'ㄲ', 'ㄳ', 'ㄴ', 'ㄵ', 'ㄶ', 'ㄷ', 'ㄹ', 'ㄺ', 'ㄻ', 'ㄼ', 'ㄽ', 'ㄾ', 'ㄿ', 'ㅀ', 'ㅁ', 'ㅂ', 'ㅄ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'];

        function disassembleHangul(char) {
            const code = char.charCodeAt(0);
            if (code >= 0xAC00 && code <= 0xD7A3) { // 완성형 한글
                const unicode = code - HANGUL_OFFSET;
                const chosungIndex = Math.floor(unicode / 588);
                const jungsungIndex = Math.floor((unicode - (chosungIndex * 588)) / 28);
                const jongsungIndex = unicode % 28;

                const disassembled = [CHOSUNG[chosungIndex]];
                if (Array.isArray(JUNGSUNG[jungsungIndex])) {
                    disassembled.push(...JUNGSUNG[jungsungIndex]);
                } else {
                    disassembled.push(JUNGSUNG[jungsungIndex]);
                }
                if (jongsungIndex !== 0) {
                    disassembled.push(JONGSUNG[jongsungIndex]);
                }
                return disassembled.join(''); // 각 자모를 합쳐서 반환
            }
            return char; // 한글이 아니면 그대로 반환
        }

        // 텍스트를 자음/모음 단위로 분리하는 함수 (한글/영어 모두 처리)
        function splitTextIntoFragments(text) {
            return Array.from(text).map(char => {
                const disassembled = disassembleHangul(char);
                if (disassembled.length > 1) { // 분리된 한글 자모가 있다면 각 자모를 별도 조각으로
                    return disassembled.split('');
                }
                return char; // 한글이 아니거나 한 글자면 그대로
            }).flat();
        }

        // CSV 로드
        Papa.parse("notedata.csv", {
            download: true, header: true,
            complete: function(results) {
                noteData = results.data.filter(row => row.note_title && row.thumbnail_url);
                startTimeLoop();
            }
        });

        function startTimeLoop() {
            updateClock(); // 초기 시계 설정
            setInterval(updateClock, 1000);
        }

        function updateClock() {
            const now = new Date();
            const h = now.getHours();
            const m = now.getMinutes();
            const s = now.getSeconds();

            const hDeg = (h * 30) + (m * 0.5);
            const mDeg = (m * 6);
            const sDeg = (s * 6);

            // 시계 바늘 움직임
            gsap.to("#hour-hand", { rotation: hDeg, duration: 0.5, ease: "back.out(2)" });
            gsap.to("#min-hand", { rotation: mDeg, duration: 0.5, ease: "back.out(2)" });
            gsap.to("#sec-hand", { rotation: sDeg, duration: 0.4, ease: "elastic.out(1, 0.3)" });

            // [핵심] 1초마다 데이터 파편 생성 (이미지 및 텍스트)
            spawnArtFragments();
        }

        function spawnArtFragments() {
            // 현재 화면의 모든 파편을 지웁니다.
            gsap.to(Array.from(universe.children), { 
                opacity: 0, scale: 0, duration: 0.5, ease: "power1.in", 
                onComplete: () => { 
                    universe.innerHTML = ''; // 완전히 비웁니다.
                    generateNewFragments();
                } 
            });
        }

        function generateNewFragments() {
            // 이미지 파편
            const imgCount = 3 + Math.floor(Math.random() * 5); // 3~7개 이미지
            for(let i=0; i<imgCount; i++) {
                const data = noteData[Math.floor(Math.random() * noteData.length)];
                const fragment = document.createElement('div');
                fragment.className = 'data-fragment';
                
                const size = 60 + Math.random() * 200; // 썸네일 크기 자유롭게 변경 (60px ~ 260px)
                const aspectRatio = 1 + Math.random(); // 가로세로 비율도 약간 랜덤
                
                fragment.style.width = size + 'px';
                fragment.style.height = (size * aspectRatio) + 'px';
                fragment.innerHTML = `<img src="${data.thumbnail_url}">`;
                universe.appendChild(fragment);

                animateFragment(fragment, size);
            }

            // 텍스트 파편
            const textData = noteData[Math.floor(Math.random() * noteData.length)];
            const splitChars = splitTextIntoFragments(textData.note_title);
            
            splitChars.forEach(char => {
                const textFragment = document.createElement('div');
                textFragment.className = 'text-fragment';
                textFragment.innerText = char;
                universe.appendChild(textFragment);

                animateFragment(textFragment, 20 + Math.random() * 30, true); // 텍스트 크기도 랜덤
            });
        }

        function animateFragment(element, baseSize, isText = false) {
            const startX = window.innerWidth / 2;
            const startY = window.innerHeight / 2;
            
            const angle = Math.random() * Math.PI * 2;
            const distance = 200 + Math.random() * 800; // 퍼지는 거리 랜덤
            const targetX = startX + Math.cos(angle) * distance - (baseSize/2);
            const targetY = startY + Math.sin(angle) * distance - (baseSize/2);

            const startScale = isText ? 1 : 0.2 + Math.random() * 0.8; // 텍스트는 바로 보이고 이미지는 작은 스케일에서 시작
            const targetScale = isText ? 1 + Math.random() * 0.5 : 0.8 + Math.random() * 1.5; // 최종 스케일 랜덤

            gsap.fromTo(element, 
                { 
                    x: startX, y: startY, 
                    scale: startScale, 
                    rotation: Math.random() * 360, // 초기 회전값 랜덤
                    opacity: 0 
                }, 
                { 
                    x: targetX, y: targetY, 
                    scale: targetScale, 
                    rotation: Math.random() * 720 - 360, // 최종 회전값 랜덤
                    opacity: 0.8 + Math.random() * 0.2, // 투명도도 랜덤
                    duration: 2 + Math.random() * 3, // 애니메이션 시간 랜덤
                    ease: "power3.out",
                    onComplete: () => {
                        gsap.to(element, { 
                            opacity: 0, 
                            scale: 0, 
                            y: targetY + (Math.random() * 100 - 50), // 약간 상하로 흔들리며 사라짐
                            duration: 1 + Math.random() * 1, 
                            delay: 0.5 + Math.random() * 1, // 사라지기 전 잠시 유지
                            ease: "power1.in",
                            onComplete: () => element.remove() 
                        });
                    }
                }
            );
        }
    </script>
</body>
</html>
