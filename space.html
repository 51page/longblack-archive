<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LongBlack Media Art : Convergence</title>
    <link href="https://fonts.googleapis.com/css2?family=Gowun+Batang:wght@700&family=Nanum+Myeongjo:wght@800&family=Montserrat:wght@300;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #080808; /* 깊은 검은색 */
            --text-particle: rgba(255, 255, 255, 0.4); /* 부유하는 텍스트 색상 (반투명) */
            --text-final: #ffffff; /* 완성된 문장 색상 */
            --accent: #ff4e00; /* 롱블랙 오렌지 포인트 */
        }

        body, html {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Montserrat', sans-serif; /* 기본은 현대적인 느낌 */
        }

        /* 캔버스 (배경 애니메이션) */
        #canvas-container {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }

        /* 안내 문구 */
        #instruction {
            position: absolute;
            bottom: 50px; width: 100%;
            text-align: center;
            color: var(--text-particle);
            font-size: 0.9rem; letter-spacing: 3px;
            text-transform: uppercase;
            animation: pulse 2s infinite;
            z-index: 10;
            pointer-events: none;
            transition: opacity 0.5s;
        }
        @keyframes pulse { 0%, 100% { opacity: 0.3; } 50% { opacity: 0.8; } }

        /* 완성된 문장이 나타나는 컨테이너 */
        #final-quote-container {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(1.2);
            width: 80%; max-width: 800px;
            text-align: center;
            z-index: 20;
            opacity: 0; /* 초기엔 숨김 */
            pointer-events: none;
            transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94); /* 부드럽고 극적인 등작 */
        }
        #final-quote-container.active {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            pointer-events: auto;
        }

        /* 완성된 문장 스타일 */
        #final-text {
            font-family: 'Nanum Myeongjo', serif; /* 명조체로 무게감 있게 */
            font-size: clamp(1.5rem, 4vw, 3rem);
            font-weight: 800;
            line-height: 1.4;
            color: var(--text-final);
            margin-bottom: 30px;
            word-break: keep-all;
            text-shadow: 0 0 20px rgba(255,255,255,0.3);
        }
        #final-source {
            font-family: 'Montserrat', sans-serif;
            font-size: 1rem;
            color: var(--accent);
            letter-spacing: 2px;
            text-transform: uppercase;
        }

    </style>
</head>
<body>

    <canvas id="canvas-container"></canvas>
    <div id="instruction">Press [ENTER] or Click to Converge</div>

    <div id="final-quote-container">
        <h1 id="final-text"></h1>
        <span id="final-source"></span>
    </div>

    <script src="quote_data.js"></script>
    <script>
        const canvas = document.getElementById('canvas-container');
        const ctx = canvas.getContext('2d');
        const finalContainer = document.getElementById('final-quote-container');
        const finalText = document.getElementById('final-text');
        const finalSource = document.getElementById('final-source');
        const instruction = document.getElementById('instruction');

        let width, height;
        let particles = [];
        let isConverging = false;
        let animationFrameId;

        // 캔버스 크기 설정
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // 부유하는 텍스트 파티클 클래스
        class TextParticle {
            constructor(text) {
                this.text = text;
                this.reset();
                // 기하학적 움직임을 위한 고유 궤도 속성
                this.orbitRadius = Math.random() * (width / 2) + 100;
                this.angle = Math.random() * Math.PI * 2;
                this.speed = (Math.random() - 0.5) * 0.02;
                this.fontSize = Math.random() * 14 + 10; // 다양한 크기
                this.opacity = Math.random() * 0.5 + 0.1;
            }

            reset() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.targetX = width / 2;
                this.targetY = height / 2;
                this.convergeSpeed = Math.random() * 0.08 + 0.04; // 중앙으로 모이는 속도
            }

            update() {
                if (isConverging) {
                    // [응집 모드] 중앙으로 강력하게 빨려들어감 (Lerp)
                    this.x += (this.targetX - this.x) * this.convergeSpeed;
                    this.y += (this.targetY - this.y) * this.convergeSpeed;
                    this.opacity -= 0.02; // 중앙에 가까워질수록 사라짐

                    // 거의 다 모였으면 멈춤
                    if (Math.abs(this.targetX - this.x) < 1 && Math.abs(this.targetY - this.y) < 1) {
                        this.opacity = 0;
                    }
                } else {
                    // [부유 모드] 기하학적 궤도 회전
                    this.angle += this.speed;
                    // 중심점을 기준으로 원형/타원형 궤도 운동
                    this.x = width / 2 + Math.cos(this.angle) * this.orbitRadius;
                    this.y = height / 2 + Math.sin(this.angle) * (this.orbitRadius * 0.6);
                    
                    // 화면 밖으로 나가면 반대편에서 등장 (궤도 유지)
                    if(this.opacity < 0.6) this.opacity += 0.005; // 다시 나타남
                }
            }

            draw() {
                if (this.opacity <= 0) return;
                ctx.font = `${this.fontSize}px 'Montserrat'`;
                ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.text, this.x, this.y);
            }
        }

        // 파티클 초기화 (문장 데이터를 단어 단위로 쪼개서 사용)
        function initParticles() {
            particles = [];
            let sampleTexts = [];
            if (typeof quoteData !== 'undefined') {
                // 데이터에서 단어들을 추출하여 부유하는 텍스트로 사용
                quoteData.forEach(q => {
                    sampleTexts.push(...q.text.split(' '));
                });
            } else {
                sampleTexts = ['Insight', 'Data', 'Sense', 'LongBlack', 'Archive', 'Connect', 'Grow', 'Read'];
            }

            // 너무 많으면 성능 저하, 적당히 200개 정도 생성
            for (let i = 0; i < 200; i++) {
                const text = sampleTexts[Math.floor(Math.random() * sampleTexts.length)];
                particles.push(new TextParticle(text));
            }
        }

        // 애니메이션 루프
        function animate() {
            ctx.clearRect(0, 0, width, height); // 화면 지우기

            // 중앙 발광 효과 (응집 시 강해짐)
            const centerGlow = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, width/2);
            centerGlow.addColorStop(0, isConverging ? 'rgba(255,78,0,0.2)' : 'rgba(255,255,255,0.05)');
            centerGlow.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = centerGlow;
            ctx.fillRect(0,0,width,height);

            // 모든 파티클 업데이트 및 그리기
            particles.forEach(p => {
                p.update();
                p.draw();
            });
            
            animationFrameId = requestAnimationFrame(animate);
        }

        // [핵심 인터랙션] 응집 및 결과 표시 트리거
        function triggerConvergence() {
            if (isConverging) return; // 이미 진행 중이면 무시

            isConverging = true;
            instruction.style.opacity = 0; // 안내 문구 숨김

            // 새로운 문장 데이터 가져오기
            let currentQuote = { text: "데이터를 불러올 수 없습니다.", source: "" };
            if (typeof quoteData !== 'undefined' && quoteData.length > 0) {
                currentQuote = quoteData[Math.floor(Math.random() * quoteData.length)];
            }

            // 0.8초 후 (파티클이 중앙에 모인 시점) 완성된 문장 보여주기
            setTimeout(() => {
                finalText.innerText = currentQuote.text;
                finalSource.innerText = `— ${currentQuote.source}`;
                finalContainer.classList.add('active');
            }, 800);
        }

        // [리셋 인터랙션] 다시 클릭하면 초기 상태로 돌아감
        function resetInteraction() {
            if (!isConverging) return;

            finalContainer.classList.remove('active');
            isConverging = false;
            instruction.style.opacity = 1;
            
            // 파티클들 다시 퍼지도록 재설정
            particles.forEach(p => {
                p.reset();
                p.opacity = Math.random() * 0.5 + 0.1;
            });
        }

        // 이벤트 리스너 등록 (엔터키 & 클릭)
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Enter') {
                isConverging ? resetInteraction() : triggerConvergence();
            }
        });
        document.addEventListener('click', () => {
            isConverging ? resetInteraction() : triggerConvergence();
        });

        // 실행
        initParticles();
        animate();

    </script>
</body>
</html>
